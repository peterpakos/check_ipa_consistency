#!/usr/bin/env bash
#
# The script checks consistency across FreeIPA servers.
# Put BIND password in to ipa_check_consistency.passwd file to stop password
# prompts.
#
# Author: Peter Pakos <peter.pakos@wandisco.com>

set -euo pipefail

readonly APP_VER="16.2.5"
readonly APP_NAME="$(basename "$0")"
readonly DIR="$(cd "$(dirname "$0")" && pwd)"
readonly TMP_DIR="$(mktemp -d)"
PASSWD_FILE="${DIR}/$(basename "$0").passwd"

SERVERS=()
DOMAIN=""
SUFFIX=""
BINDDN="cn=Directory Manager"
BINDPW=""
FIRST_COLUMN=20
MIDDLE_COLUMNS=5
LAST_COLUMN=11

IFS=$'\n'

display_version() {
  printf "%s version %s\n" "$APP_NAME" "$APP_VER"
}

display_help() {
  display_version
  cat <<HELP
Usage: ${APP_NAME} [OPTIONS]
AVAILABLE OPTIONS:
-H  List of hosts (e.g. "server1 server2 server3")
-d  IPA domain (e.g. "ipa.domain.com")
-s  LDAP root suffix, if not domain based (default: "dc=ipa,dc=domain,dc=com")
-D  BIND DN (default: cn=Directory Manager)
-W  BIND password (prompt for one if not supplied)
-p  Password file (default: $(basename "$0").passwd)
-h  Print this help summary page
-v  Print version number
HELP
}

get_pass() {
  if [[ -z "$BINDPW" ]]; then
    if [[ -r "$PASSWD_FILE" ]]; then
      BINDPW="$(<"$PASSWD_FILE")"
      printf "BIND password loaded from file %s\n" "$(basename "$PASSWD_FILE")"
    else
      printf "%s password: " "${BINDDN#cn=}"
      read -rs BINDPW
      printf "\n"
    fi
  fi
}

validate_pass() {
  if ! ldapwhoami -x -h "${SERVERS[1]}.${DOMAIN}" -D "$BINDDN" -w "$BINDPW" &>/dev/null; then
    printf "BIND unsuccessful, check details and try again.\n" >&2
    exit 1
  fi
  printf "\n"
}

hr() {
  local len=$(( FIRST_COLUMN + ${#SERVERS[@]} * MIDDLE_COLUMNS + LAST_COLUMN ))

  printf "=%.0s" $(seq $len)
  printf "\n"
}

display_header() {
  local server=""

  printf "%-${FIRST_COLUMN}s" "FreeIPA servers:"
  for server in "${SERVERS[@]}"; do
    printf "%-${MIDDLE_COLUMNS}s" "$server"
  done
  printf "%-${LAST_COLUMN}s\n" "Consistent?"
  hr
}

is_consistent() {
  local dir="$1"

  if diff --from-file "$dir"/* &>/dev/null; then
    printf "YES"
  else
    printf "NO"
  fi
}

anon_bind() {
  local server="" state=""
  local dir="${TMP_DIR}/anon_bind"

  mkdir -p "$dir"

  printf "%-${FIRST_COLUMN}s" "Anonymous BIND"
  for server in "${SERVERS[@]}"; do
    (
    if ! state=$(ldapsearch -LLLx -h "${server}.${DOMAIN}" \
      -D "$BINDDN" -w "$BINDPW" -b "cn=config" "(cn=config)" \
      "nsslapd-allow-anonymous-access" 2>/dev/null \
      | awk -F'nsslapd-allow-anonymous-access: ' \
      '/nsslapd-allow-anonymous-access/ {print $2}'); then
      state="FAIL"
    fi
    printf "%s" "$state" > "${dir}/${server}"
    ) &
  done
  wait
  for server in "${SERVERS[@]}"; do
    printf "%-${MIDDLE_COLUMNS}s" "$(< "${dir}/${server}")"
  done
  printf "%-${LAST_COLUMN}s\n" "$(is_consistent "$dir")"
}

users() {
  local server="" count=""
  local dir="${TMP_DIR}/users"
  mkdir -p "$dir"

  printf "%-${FIRST_COLUMN}s" "Users"
  for server in "${SERVERS[@]}"; do
    (
    if ! count=$(ldapsearch -LLLx -h "${server}.${DOMAIN}" \
      -D "$BINDDN" -w "$BINDPW" -b "cn=users,cn=accounts,${SUFFIX}" -s one \
      "(uid=*)" "dn" 2>/dev/null | grep -c 'dn: '); then
      count="FAIL"
    fi
    printf "%s" "$count" > "${dir}/${server}"
    ) &
  done
  wait
  for server in "${SERVERS[@]}"; do
    printf "%-${MIDDLE_COLUMNS}s" "$(< "${dir}/${server}")"
  done
  printf "%-${LAST_COLUMN}s\n" "$(is_consistent "$dir")"
}

groups() {
  local server="" count=""
  local dir="${TMP_DIR}/groups"

  mkdir -p "$dir"

  printf "%-${FIRST_COLUMN}s" "Groups"
  for server in "${SERVERS[@]}"; do
    (
    if ! count=$(ldapsearch -LLLx -h "${server}.${DOMAIN}" \
      -D "$BINDDN" -w "$BINDPW" -b "cn=groups,cn=accounts,${SUFFIX}" -s one \
      "(cn=*)" "dn" 2>/dev/null | grep -c 'dn: '); then
      count="FAIL"
    fi
    printf "%s" "$count" > "${dir}/${server}"
    ) &
  done
  wait
  for server in "${SERVERS[@]}"; do
    printf "%-${MIDDLE_COLUMNS}s" "$(< "${dir}/${server}")"
  done
  printf "%-${LAST_COLUMN}s\n" "$(is_consistent "$dir")"
}

ldap_conflicts() {
  local server="" conflicts=""
  local dir="${TMP_DIR}/ldap_conflicts"

  mkdir -p "$dir"

  printf "%-${FIRST_COLUMN}s" "LDAP conflicts"
  for server in "${SERVERS[@]}"; do
    (
    if ! conflicts=$(ldapsearch -LLLx -h "${server}.${DOMAIN}" \
      -D "$BINDDN" -w "$BINDPW" -b "${SUFFIX}" -s sub "nsds5ReplConflict=*" \* \
      "nsds5ReplConflict" 2>/dev/null); then
      conflicts="FAIL"
    fi
    if [[ -n "$conflicts" ]]; then
      conflicts="YES"
    else
      conflicts="NO"
    fi
    printf "%s" "$conflicts" > "${dir}/${server}"
    ) &
  done
  wait
  for server in "${SERVERS[@]}"; do
    printf "%-${MIDDLE_COLUMNS}s" "$(< "${dir}/${server}")"
  done
  printf "%-${LAST_COLUMN}s\n" "$(is_consistent "$dir")"
}

hosts() {
  local server="" count=""
  local dir="${TMP_DIR}/hosts"

  mkdir -p "$dir"

  printf "%-${FIRST_COLUMN}s" "Hosts"
  for server in "${SERVERS[@]}"; do
    (
    if ! count=$(ldapsearch -LLLx -h "${server}.${DOMAIN}" \
      -D "$BINDDN" -w "$BINDPW" -b "cn=computers,cn=accounts,${SUFFIX}" -s one \
      "(fqdn=*)" "dn" 2>/dev/null | grep -c 'dn: '); then
      count="FAIL"
    fi
    printf "%s" "$count" > "${dir}/${server}"
    ) &
  done
  wait
  for server in "${SERVERS[@]}"; do
    printf "%-${MIDDLE_COLUMNS}s" "$(< "${dir}/${server}")"
  done
  printf "%-${LAST_COLUMN}s\n" "$(is_consistent "$dir")"
}

hostgroups() {
  local server="" count=""
  local dir="${TMP_DIR}/hostgroups"

  mkdir -p "$dir"

  printf "%-${FIRST_COLUMN}s" "Hostgroups"
  for server in "${SERVERS[@]}"; do
    (
    if ! count=$(ldapsearch -LLLx -h "${server}.${DOMAIN}" \
      -D "$BINDDN" -w "$BINDPW" -b "cn=hostgroups,cn=accounts,${SUFFIX}" \
      -s one "(cn=*)" "dn" 2>/dev/null | grep -c 'dn: '); then
      count="FAIL"
    fi
    printf "%s" "$count" > "${dir}/${server}"
    ) &
  done
  wait
  for server in "${SERVERS[@]}"; do
    printf "%-${MIDDLE_COLUMNS}s" "$(< "${dir}/${server}")"
  done
  printf "%-${LAST_COLUMN}s\n" "$(is_consistent "$dir")"
}

hbac_rules() {
  local server="" count=""
  local dir="${TMP_DIR}/hbac_rules"

  mkdir -p "$dir"

  printf "%-${FIRST_COLUMN}s" "HBAC rules"
  for server in "${SERVERS[@]}"; do
    (
    if ! count=$(ldapsearch -LLLx -h "${server}.${DOMAIN}" \
      -D "$BINDDN" -w "$BINDPW" -b "cn=hbac,${SUFFIX}" -s one \
      "(ipaUniqueID=*)" "dn" 2>/dev/null | grep -c 'dn: '); then
      count="FAIL"
    fi
    printf "%s" "$count" > "${dir}/${server}"
    ) &
  done
  wait
  for server in "${SERVERS[@]}"; do
    printf "%-${MIDDLE_COLUMNS}s" "$(< "${dir}/${server}")"
  done
  printf "%-${LAST_COLUMN}s\n" "$(is_consistent "$dir")"
}

sudo_rules() {
  local server="" count="" first_column=""
  local dir="${TMP_DIR}/hbac_rules"

  mkdir -p "$dir"

  printf "%-${FIRST_COLUMN}s" "SUDO rules"
  for server in "${SERVERS[@]}"; do
    (
    if ! count=$(ldapsearch -LLLx -h "${server}.${DOMAIN}" -D "$BINDDN" \
      -w "$BINDPW" -b "cn=sudorules,cn=sudo,${SUFFIX}" -s one \
      "(ipaUniqueID=*)" "dn" 2>/dev/null | grep -c 'dn: '); then
      count="FAIL"
    fi
    printf "%s" "$count" > "${dir}/${server}"
    ) &
  done
  wait
  for server in "${SERVERS[@]}"; do
    printf "%-${MIDDLE_COLUMNS}s" "$(< "${dir}/${server}")"
  done
  printf "%-${LAST_COLUMN}s\n" "$(is_consistent "$dir")"
}

replication() {
  local server="" agreements="" state="" a="" max=0 i=""
  local dir="${TMP_DIR}/replication"
  local suffix=""
  suffix=$(sed -e 's@=@\\3D@g' -e 's@,@\\,@g' <<<"$SUFFIX")

  mkdir -p "$dir"

  for server in "${SERVERS[@]}"; do
    (
    if ! agreements=$(ldapsearch -LLLx -h "${server}.${DOMAIN}" -D "$BINDDN" \
      -w "$BINDPW" -b "cn=replica,cn=${suffix},\
      cn=mapping tree,cn=config" -s one nsDS5ReplicaHost \
      nsds5replicaLastUpdateStatus 2>/dev/null \
      | awk '{if ($0 ~ /nsDS5ReplicaHost/) printf("%s",$2); if ($0 ~ /nsds5replicaLastUpdateStatus/) printf(" %s\n",$2)}' \
      | sed -e "s/\.${DOMAIN}//g"); then
      state="FAIL"
    fi
    for a in $agreements; do
      printf "%s\n" "$a" >>"${dir}/${server}"
    done
    ) &
  done
  wait
  for server in "${SERVERS[@]}"; do
    if [[ -r "${dir}/${server}" ]]; then
      n=$(wc -l < "${dir}/${server}")
    else
      n=0
    fi
    [[ $n -gt $max ]] && max=$n
  done
  for ((i=1; i<=max; i++)); do
    [[ $i -eq 1 ]] && first_column="Replication status" || first_column=""
    printf "%-${FIRST_COLUMN}s" "$first_column"
    for server in "${SERVERS[@]}"; do
      if [[ -s "${dir}/${server}" ]]; then
        line=$(sed -n '1p' "${dir}/${server}")
        sed -i -e '1d' "${dir}/${server}"
      else
        line=""
      fi
      printf "%-${MIDDLE_COLUMNS}s" "$line"
    done
    printf "\n"
  done
}

update_cols() {
  local max=0

  for server in "${SERVERS[@]}"; do
    [[ ${#server} -gt $max ]] && max=${#server}
  done
  max=$((max+4))
  if [[ $max -gt $MIDDLE_COLUMNS ]]; then
    MIDDLE_COLUMNS=$max
  fi
}

get_opts() {
  while getopts ":vhd:D:W:s:p:H:" opt; do
    case $opt in
      v)
        display_version
        exit 0
        ;;
      h)
        display_help
        exit 0
        ;;
      d)
        DOMAIN="${OPTARG,,}"
        SUFFIX="dc=${DOMAIN//./,dc=}"
        ;;
      D)
        BINDDN="${OPTARG}"
        ;;
      W)
        BINDPW="${OPTARG}"
        ;;
      s)
        SUFFIX="${OPTARG}"
        ;;
      p)
        PASSWD_FILE="${OPTARG}"
        if [[ ! -r "$PASSWD_FILE" ]]; then
          printf "Unable to open password file %s, exiting.\n" "$PASSWD_FILE"
          exit 1
        fi
        ;;
      H)
        IFS=" "
        SERVERS=($OPTARG)
        IFS=$'\n'
        update_cols
        ;;
      *)
        printf "Invalid option: %s\n\n" "$OPTARG"
        display_help
        exit 1
        ;;
    esac
  done
}

check_vars() {
  local fail=0

  if [[ ${#SERVERS[@]} -lt 1 ]]; then
    printf "Hosts not specified (-H)\n" >&2
    fail=1
  fi
  if [[ -z "$DOMAIN" ]]; then
    printf "IPA domain not specified (-d)\n" >&2
    fail=1
  fi

  if [[ $fail -ne 0 ]]; then
    printf "\n"
    display_help
    exit 1
  fi
}

query_servers() {
  users > "$TMP_DIR/users.out" &
  groups > "$TMP_DIR/groups.out" &
  hosts > "$TMP_DIR/hosts.out" &
  hostgroups > "$TMP_DIR/hostgroups.out" &
  hbac_rules > "$TMP_DIR/hbac_rules.out" &
  sudo_rules > "$TMP_DIR/sudo_rules.out" &
  ldap_conflicts > "$TMP_DIR/ldap_conflicts.out" &
  anon_bind > "$TMP_DIR/anon_bind.out" &
  replication > "$TMP_DIR/replication.out" &
  wait
}

display_data() {
  printf "%s\n" "$(< "${TMP_DIR}/users.out")"
  printf "%s\n" "$(< "${TMP_DIR}/groups.out")"
  printf "%s\n" "$(< "${TMP_DIR}/hosts.out")"
  printf "%s\n" "$(< "${TMP_DIR}/hostgroups.out")"
  printf "%s\n" "$(< "${TMP_DIR}/hbac_rules.out")"
  printf "%s\n" "$(< "${TMP_DIR}/sudo_rules.out")"
  printf "%s\n" "$(< "${TMP_DIR}/ldap_conflicts.out")"
  printf "%s\n" "$(< "${TMP_DIR}/anon_bind.out")"
  printf "%s\n" "$(< "${TMP_DIR}/replication.out")"
}

cleanup() {
  rm -rf "$TMP_DIR"
}

main() {
  get_opts "$@"
  check_vars
  get_pass
  validate_pass
  display_header
  query_servers
  display_data
  hr
  cleanup
}

main "$@"
